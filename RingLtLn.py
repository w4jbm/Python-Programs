'''

RingLtLn.py
Copyright (c) 2019 by James McClanahan W4JBM

This program takes a center coordianate and generates coordinates for
"rings" of coordinates some distance from it. Inputs are the variables:

cntr_coord: The latitude and longitude of the center point
rings:      The number of rings to be generated
dist:       The distance (in miles) between the rings

The output is a list of latitudes and longitudes for each point on
each ring.

This code can be run without having to install Python using the online
environment at:

https://www.onlinegdb.com/

(Make sure to select Python 3 as the Language.)

Version History:

0.1 - Initial Release

'''

# We will need some functions from the math library

import math
import numpy

# This code is modified from code found here:
# https://janakiev.com/blog/gps-points-distance-python/
#
# Most of my work tends to be in miles, not meters. This approach
# was used instead of the geopy library to allow greater portability.
#
# We only need to calculate two distances anyway.

def haversine(coord1, coord2):
    R = 3958.8  # Earth radius in miles
    lat1, lon1 = coord1
    lat2, lon2 = coord2

    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    dphi       = math.radians(lat2 - lat1)
    dlambda    = math.radians(lon2 - lon1)

    a = math.sin(dphi/2)**2 + \
        math.cos(phi1)*math.cos(phi2)*math.sin(dlambda/2)**2

    return 2*R*math.atan2(math.sqrt(a), math.sqrt(1 - a))


# This is the lat/long for Bowdon Junction, GA...
# "Where the population doubles, everytime the stoplight
#  on the highway turns red..."
#
# The value is stored as a tuple and can be referenced by using
# cntr_coord[0] for latitude or cntr_coord[1] for latitude.
#
# You will need to modify to reflect where you want to center the rings
# generated by the program.

cntr_coord = 33.6632, -85.1469


# How many rings do we want?

rings = 7


# What spacing do we want on concentric rings?
# (0.25 indicates a quarter mile--7 rings will give us rings
# going out 2.0 miles.)

dist = 0.25


# We must determine the change in lat and the change in lon
# associated with the distance between our rings. This will vary
# by the center coordinate. This is not exact and doing something
# like ten rings with 100 mile spacing isn't going to work.
#
# Generally our sanity check for this will come from plotting the
# results on a map. Things should work reasonably well for the kinds
# of distances typical in wireless coverage work.

print ("Calibrating for center coordinate...")

test_coord = cntr_coord[0]+0.01, cntr_coord[1]
lt1_adj = haversine(cntr_coord, test_coord)
lt1_adj = (0.01 / lt1_adj) * dist

test_coord = cntr_coord[0], cntr_coord[1]+0.01
ln1_adj = haversine(cntr_coord, test_coord)
ln1_adj = (0.01 / ln1_adj) * dist

# A reasonable approximation for the points at 45, 135, 225, and 315 degrees
# is to multiply the vertical and horizontal change constant by SQRT(2)/2.
#
# This is plugged in as the constant 0.707107 instead of calculating it out.

lt2_adj = lt1_adj * 0.707107
ln2_adj = ln1_adj * 0.707107

print(" - Center coordinate is ", cntr_coord, ".", sep='')
print(" - Latitude step will be", lt1_adj, "for", dist, "miles.")
print(" - Longitude steps will be", ln1_adj, "for", dist, "miles.")
print(" - For others, steps will be", lt2_adj, " and ", ln2_adj, "for", dist, "miles.")
print("")

# A lot of this uses a "brute force" approach. It works and was easy
# to implement, but it also makes it easier to understand (and
# potentially modify) for someone than short-but-cryptic code would
# be.

coord_000 = cntr_coord
coord_045 = cntr_coord
coord_090 = cntr_coord
coord_135 = cntr_coord
coord_180 = cntr_coord
coord_225 = cntr_coord
coord_270 = cntr_coord
coord_315 = cntr_coord
rd = 0

# As the points are output, the naming convention is 'P' for
# Point, then a 4 digit range (in 100ths of miles with the
# decimal point removed), then an R for Range, then a 3
# digit angle in degrees, and finally an A for Azimuth.
#
# The name, latitude, and longitude is given for each point
# to allow simple import as a CSV file.
#
# The center coordiante is printed prior to beginning of
# generating the rings

print("P0000R000A", ", ", cntr_coord[0], ",", cntr_coord[1], sep='')
print("")


# We will loop through each ring, adding the incremental amount
# we determined earlier and then printing the results.

for x in range(rings):
    rd = rd + dist
    print("Printing for radius of ", rd, "...")
    coord_000 = coord_000[0]+lt1_adj, coord_000[1]
    coord_045 = coord_045[0]+lt2_adj, coord_045[1]+ln2_adj
    coord_090 = coord_090[0], coord_090[1]+ln1_adj
    coord_135 = coord_135[0]-lt2_adj, coord_135[1]+ln2_adj
    coord_180 = coord_180[0]-lt1_adj, coord_180[1]
    coord_225 = coord_225[0]-lt2_adj, coord_225[1]-ln2_adj
    coord_270 = coord_270[0], coord_270[1]-ln1_adj
    coord_315 = coord_315[0]+lt2_adj, coord_315[1]-ln2_adj

# when printing...
#
# print('hello world', end='')     will suppress the endline terminator
# print('hello', 'world', sep='')  will suppress the whitespace separator
#                                  between items

    rds = str(int((100+rd)*100)) # convert radus to string
    rds = rds[1:5]
    print("P", rds, "R000A, ", coord_000[0], ", ", coord_000[1], sep='')
    print("P", rds, "R045A, ", coord_045[0], ", ", coord_045[1], sep='')
    print("P", rds, "R090A, ", coord_090[0], ", ", coord_090[1], sep='')
    print("P", rds, "R135A, ", coord_135[0], ", ", coord_135[1], sep='')
    print("P", rds, "R180A, ", coord_180[0], ", ", coord_180[1], sep='')
    print("P", rds, "R225A, ", coord_225[0], ", ", coord_225[1], sep='')
    print("P", rds, "R270A, ", coord_270[0], ", ", coord_270[1], sep='')
    print("P", rds, "R315A, ", coord_315[0], ", ", coord_315[1], sep='')
    print("")


# ...and we're done...

print("List complete!")
